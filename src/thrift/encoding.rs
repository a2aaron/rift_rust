// Autogenerated by Thrift Compiler (0.17.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

#![allow(unused_imports)]
#![allow(unused_extern_crates)]
#![allow(clippy::too_many_arguments, clippy::type_complexity, clippy::vec_box)]
#![cfg_attr(rustfmt, rustfmt_skip)]

use std::cell::RefCell;
use std::collections::{BTreeMap, BTreeSet};
use std::convert::{From, TryFrom};
use std::default::Default;
use std::error::Error;
use std::fmt;
use std::fmt::{Display, Formatter};
use std::rc::Rc;

use thrift::OrderedFloat;
use thrift::{ApplicationError, ApplicationErrorKind, ProtocolError, ProtocolErrorKind, TThriftClient};
use thrift::protocol::{TFieldIdentifier, TListIdentifier, TMapIdentifier, TMessageIdentifier, TMessageType, TInputProtocol, TOutputProtocol, TSerializable, TSetIdentifier, TStructIdentifier, TType};
use thrift::protocol::field_id;
use thrift::protocol::verify_expected_message_type;
use thrift::protocol::verify_expected_sequence_number;
use thrift::protocol::verify_expected_service_call;
use thrift::protocol::verify_required_field_exists;
use thrift::server::TProcessor;

use crate::models::common;

//
// PacketHeader
//

/// Common RIFT packet header.
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct PacketHeader {
  /// Major version of protocol.
  pub major_version: common::VersionType,
  /// Minor version of protocol.
  pub minor_version: common::MinorVersionType,
  /// Node sending the packet, in case of LIE/TIRE/TIDE
  /// also the originator of it.
  pub sender: common::SystemIDType,
  /// Level of the node sending the packet, required on everything
  /// except LIEs. Lack of presence on LIEs indicates UNDEFINED_LEVEL
  /// and is used in ZTP procedures.
  pub level: Option<common::LevelType>,
}

impl PacketHeader {
  pub fn new<F4>(major_version: common::VersionType, minor_version: common::MinorVersionType, sender: common::SystemIDType, level: F4) -> PacketHeader where F4: Into<Option<common::LevelType>> {
    PacketHeader {
      major_version,
      minor_version,
      sender,
      level: level.into(),
    }
  }
}

impl TSerializable for PacketHeader {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<PacketHeader> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<common::VersionType> = None;
    let mut f_2: Option<common::MinorVersionType> = None;
    let mut f_3: Option<common::SystemIDType> = None;
    let mut f_4: Option<common::LevelType> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i8()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i16()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i8()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("PacketHeader.major_version", &f_1)?;
    verify_required_field_exists("PacketHeader.minor_version", &f_2)?;
    verify_required_field_exists("PacketHeader.sender", &f_3)?;
    let ret = PacketHeader {
      major_version: f_1.expect("auto-generated code should have checked for presence of required fields"),
      minor_version: f_2.expect("auto-generated code should have checked for presence of required fields"),
      sender: f_3.expect("auto-generated code should have checked for presence of required fields"),
      level: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PacketHeader");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("major_version", TType::I08, 1))?;
    o_prot.write_i8(self.major_version)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("minor_version", TType::I16, 2))?;
    o_prot.write_i16(self.minor_version)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sender", TType::I64, 3))?;
    o_prot.write_i64(self.sender)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.level {
      o_prot.write_field_begin(&TFieldIdentifier::new("level", TType::I08, 4))?;
      o_prot.write_i8(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// Community
//

/// Prefix community.
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Community {
  /// Higher order bits
  pub top: i32,
  /// Lower order bits
  pub bottom: i32,
}

impl Community {
  pub fn new(top: i32, bottom: i32) -> Community {
    Community {
      top,
      bottom,
    }
  }
}

impl TSerializable for Community {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Community> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("Community.top", &f_1)?;
    verify_required_field_exists("Community.bottom", &f_2)?;
    let ret = Community {
      top: f_1.expect("auto-generated code should have checked for presence of required fields"),
      bottom: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Community");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("top", TType::I32, 1))?;
    o_prot.write_i32(self.top)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("bottom", TType::I32, 2))?;
    o_prot.write_i32(self.bottom)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// Neighbor
//

/// Neighbor structure.
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Neighbor {
  /// System ID of the originator.
  pub originator: common::SystemIDType,
  /// ID of remote side of the link.
  pub remote_id: common::LinkIDType,
}

impl Neighbor {
  pub fn new(originator: common::SystemIDType, remote_id: common::LinkIDType) -> Neighbor {
    Neighbor {
      originator,
      remote_id,
    }
  }
}

impl TSerializable for Neighbor {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Neighbor> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<common::SystemIDType> = None;
    let mut f_2: Option<common::LinkIDType> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("Neighbor.originator", &f_1)?;
    verify_required_field_exists("Neighbor.remote_id", &f_2)?;
    let ret = Neighbor {
      originator: f_1.expect("auto-generated code should have checked for presence of required fields"),
      remote_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Neighbor");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("originator", TType::I64, 1))?;
    o_prot.write_i64(self.originator)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("remote_id", TType::I32, 2))?;
    o_prot.write_i32(self.remote_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NodeCapabilities
//

/// Capabilities the node supports.
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NodeCapabilities {
  /// Must advertise supported minor version dialect that way.
  pub protocol_minor_version: common::MinorVersionType,
  /// indicates that node supports flood reduction.
  pub flood_reduction: Option<bool>,
  /// indicates place in hierarchy, i.e. top-of-fabric or
  /// leaf only (in ZTP) or support for leaf-2-leaf
  /// procedures.
  pub hierarchy_indications: Option<common::HierarchyIndications>,
  /// <auto-evpn>
  /// indicates whether auto-evpn feature is implemented on this node (but not necessarily enabled).
  pub auto_evpn_support: Option<bool>,
  /// <auto-flood-reflection>
  /// indicates whether auto-flood-reflection feature is implemented on this node (but not necessarily enabled).
  pub auto_flood_reflection_support: Option<bool>,
}

impl NodeCapabilities {
  pub fn new<F2, F3, F10, F20>(protocol_minor_version: common::MinorVersionType, flood_reduction: F2, hierarchy_indications: F3, auto_evpn_support: F10, auto_flood_reflection_support: F20) -> NodeCapabilities where F2: Into<Option<bool>>, F3: Into<Option<common::HierarchyIndications>>, F10: Into<Option<bool>>, F20: Into<Option<bool>> {
    NodeCapabilities {
      protocol_minor_version,
      flood_reduction: flood_reduction.into(),
      hierarchy_indications: hierarchy_indications.into(),
      auto_evpn_support: auto_evpn_support.into(),
      auto_flood_reflection_support: auto_flood_reflection_support.into(),
    }
  }
}

impl TSerializable for NodeCapabilities {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NodeCapabilities> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<common::MinorVersionType> = None;
    let mut f_2: Option<bool> = None;
    let mut f_3: Option<common::HierarchyIndications> = None;
    let mut f_10: Option<bool> = None;
    let mut f_20: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i16()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = common::HierarchyIndications::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        10 => {
          let val = i_prot.read_bool()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_bool()?;
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NodeCapabilities.protocol_minor_version", &f_1)?;
    let ret = NodeCapabilities {
      protocol_minor_version: f_1.expect("auto-generated code should have checked for presence of required fields"),
      flood_reduction: f_2,
      hierarchy_indications: f_3,
      auto_evpn_support: f_10,
      auto_flood_reflection_support: f_20,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NodeCapabilities");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("protocol_minor_version", TType::I16, 1))?;
    o_prot.write_i16(self.protocol_minor_version)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.flood_reduction {
      o_prot.write_field_begin(&TFieldIdentifier::new("flood_reduction", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.hierarchy_indications {
      o_prot.write_field_begin(&TFieldIdentifier::new("hierarchy_indications", TType::I32, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.auto_evpn_support {
      o_prot.write_field_begin(&TFieldIdentifier::new("auto_evpn_support", TType::Bool, 10))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.auto_flood_reflection_support {
      o_prot.write_field_begin(&TFieldIdentifier::new("auto_flood_reflection_support", TType::Bool, 20))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// LinkCapabilities
//

/// Link capabilities.
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct LinkCapabilities {
  /// Indicates that the link is supporting BFD.
  pub bfd: Option<bool>,
  /// Indicates whether the interface will support IPv4 forwarding.
  pub ipv4_forwarding_capable: Option<bool>,
}

impl LinkCapabilities {
  pub fn new<F1, F2>(bfd: F1, ipv4_forwarding_capable: F2) -> LinkCapabilities where F1: Into<Option<bool>>, F2: Into<Option<bool>> {
    LinkCapabilities {
      bfd: bfd.into(),
      ipv4_forwarding_capable: ipv4_forwarding_capable.into(),
    }
  }
}

impl TSerializable for LinkCapabilities {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<LinkCapabilities> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    let mut f_2: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = LinkCapabilities {
      bfd: f_1,
      ipv4_forwarding_capable: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("LinkCapabilities");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.bfd {
      o_prot.write_field_begin(&TFieldIdentifier::new("bfd", TType::Bool, 1))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.ipv4_forwarding_capable {
      o_prot.write_field_begin(&TFieldIdentifier::new("ipv4_forwarding_capable", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for LinkCapabilities {
  fn default() -> Self {
    LinkCapabilities{
      bfd: Some(false),
      ipv4_forwarding_capable: Some(false),
    }
  }
}

//
// LIEPacket
//

/// RIFT LIE Packet.
/// 
/// @note: this node's level is already included on the packet header
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct LIEPacket {
  /// Node or adjacency name.
  pub name: Option<String>,
  /// Local link ID.
  pub local_id: common::LinkIDType,
  /// UDP port to which we can receive flooded TIEs.
  pub flood_port: common::UDPPortType,
  /// Layer 3 MTU, used to discover mismatch.
  pub link_mtu_size: Option<common::MTUSizeType>,
  /// Local link bandwidth on the interface.
  pub link_bandwidth: Option<common::BandwithInMegaBitsType>,
  /// Reflects the neighbor once received to provide
  /// 3-way connectivity.
  pub neighbor: Option<Neighbor>,
  /// Node's PoD.
  pub pod: Option<common::PodType>,
  /// Node capabilities supported.
  pub node_capabilities: NodeCapabilities,
  /// Capabilities of this link.
  pub link_capabilities: Option<LinkCapabilities>,
  /// Required holdtime of the adjacency, i.e. for how
  /// long a period should adjacency be kept up without valid LIE reception.
  pub holdtime: common::TimeIntervalInSecType,
  /// Optional, unsolicited, downstream assigned locally significant label
  /// value for the adjacency.
  pub label: Option<common::LabelType>,
  /// Indicates that the level on the LIE must not be used
  /// to derive a ZTP level by the receiving node.
  pub not_a_ztp_offer: Option<bool>,
  /// Indicates to northbound neighbor that it should
  /// be reflooding TIEs received from this node to achieve flood
  /// reduction and balancing for northbound flooding.
  pub you_are_flood_repeater: Option<bool>,
  /// Indicates to neighbor to flood node TIEs only and slow down
  /// all other TIEs. Ignored when received from southbound neighbor.
  pub you_are_sending_too_quickly: Option<bool>,
  /// Instance name in case multiple RIFT instances running on same
  /// interface.
  pub instance_name: Option<String>,
  /// <auto-evpn>
  /// provides the optional ID of the configured auto-evpn fabric.
  pub fabric_id: Option<common::FabricIDType>,
  /// provides optional version of EVPN ZTP as 256 * MAJOR + MINOR
  pub auto_evpn_version: Option<i16>,
  /// It provides optional version of FR ZTP as 256 * MAJOR + MINOR, indicates support for auto FR
  pub auto_flood_reflection_version: Option<i16>,
  pub auto_flood_reflection_cluster_id: Option<common::FloodReflectionClusterIDType>,
}

impl LIEPacket {
  pub fn new<F1, F4, F5, F6, F7, F11, F13, F21, F22, F23, F24, F35, F36, F40, F41>(name: F1, local_id: common::LinkIDType, flood_port: common::UDPPortType, link_mtu_size: F4, link_bandwidth: F5, neighbor: F6, pod: F7, node_capabilities: NodeCapabilities, link_capabilities: F11, holdtime: common::TimeIntervalInSecType, label: F13, not_a_ztp_offer: F21, you_are_flood_repeater: F22, you_are_sending_too_quickly: F23, instance_name: F24, fabric_id: F35, auto_evpn_version: F36, auto_flood_reflection_version: F40, auto_flood_reflection_cluster_id: F41) -> LIEPacket where F1: Into<Option<String>>, F4: Into<Option<common::MTUSizeType>>, F5: Into<Option<common::BandwithInMegaBitsType>>, F6: Into<Option<Neighbor>>, F7: Into<Option<common::PodType>>, F11: Into<Option<LinkCapabilities>>, F13: Into<Option<common::LabelType>>, F21: Into<Option<bool>>, F22: Into<Option<bool>>, F23: Into<Option<bool>>, F24: Into<Option<String>>, F35: Into<Option<common::FabricIDType>>, F36: Into<Option<i16>>, F40: Into<Option<i16>>, F41: Into<Option<common::FloodReflectionClusterIDType>> {
    LIEPacket {
      name: name.into(),
      local_id,
      flood_port,
      link_mtu_size: link_mtu_size.into(),
      link_bandwidth: link_bandwidth.into(),
      neighbor: neighbor.into(),
      pod: pod.into(),
      node_capabilities,
      link_capabilities: link_capabilities.into(),
      holdtime,
      label: label.into(),
      not_a_ztp_offer: not_a_ztp_offer.into(),
      you_are_flood_repeater: you_are_flood_repeater.into(),
      you_are_sending_too_quickly: you_are_sending_too_quickly.into(),
      instance_name: instance_name.into(),
      fabric_id: fabric_id.into(),
      auto_evpn_version: auto_evpn_version.into(),
      auto_flood_reflection_version: auto_flood_reflection_version.into(),
      auto_flood_reflection_cluster_id: auto_flood_reflection_cluster_id.into(),
    }
  }
}

impl TSerializable for LIEPacket {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<LIEPacket> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<common::LinkIDType> = None;
    let mut f_3: Option<common::UDPPortType> = None;
    let mut f_4: Option<common::MTUSizeType> = None;
    let mut f_5: Option<common::BandwithInMegaBitsType> = None;
    let mut f_6: Option<Neighbor> = None;
    let mut f_7: Option<common::PodType> = None;
    let mut f_10: Option<NodeCapabilities> = None;
    let mut f_11: Option<LinkCapabilities> = None;
    let mut f_12: Option<common::TimeIntervalInSecType> = None;
    let mut f_13: Option<common::LabelType> = None;
    let mut f_21: Option<bool> = None;
    let mut f_22: Option<bool> = None;
    let mut f_23: Option<bool> = None;
    let mut f_24: Option<String> = None;
    let mut f_35: Option<common::FabricIDType> = None;
    let mut f_36: Option<i16> = None;
    let mut f_40: Option<i16> = None;
    let mut f_41: Option<common::FloodReflectionClusterIDType> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i16()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        6 => {
          let val = Neighbor::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i32()?;
          f_7 = Some(val);
        },
        10 => {
          let val = NodeCapabilities::read_from_in_protocol(i_prot)?;
          f_10 = Some(val);
        },
        11 => {
          let val = LinkCapabilities::read_from_in_protocol(i_prot)?;
          f_11 = Some(val);
        },
        12 => {
          let val = i_prot.read_i16()?;
          f_12 = Some(val);
        },
        13 => {
          let val = i_prot.read_i32()?;
          f_13 = Some(val);
        },
        21 => {
          let val = i_prot.read_bool()?;
          f_21 = Some(val);
        },
        22 => {
          let val = i_prot.read_bool()?;
          f_22 = Some(val);
        },
        23 => {
          let val = i_prot.read_bool()?;
          f_23 = Some(val);
        },
        24 => {
          let val = i_prot.read_string()?;
          f_24 = Some(val);
        },
        35 => {
          let val = i_prot.read_i16()?;
          f_35 = Some(val);
        },
        36 => {
          let val = i_prot.read_i16()?;
          f_36 = Some(val);
        },
        40 => {
          let val = i_prot.read_i16()?;
          f_40 = Some(val);
        },
        41 => {
          let val = i_prot.read_i32()?;
          f_41 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("LIEPacket.local_id", &f_2)?;
    verify_required_field_exists("LIEPacket.flood_port", &f_3)?;
    verify_required_field_exists("LIEPacket.node_capabilities", &f_10)?;
    verify_required_field_exists("LIEPacket.holdtime", &f_12)?;
    let ret = LIEPacket {
      name: f_1,
      local_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      flood_port: f_3.expect("auto-generated code should have checked for presence of required fields"),
      link_mtu_size: f_4,
      link_bandwidth: f_5,
      neighbor: f_6,
      pod: f_7,
      node_capabilities: f_10.expect("auto-generated code should have checked for presence of required fields"),
      link_capabilities: f_11,
      holdtime: f_12.expect("auto-generated code should have checked for presence of required fields"),
      label: f_13,
      not_a_ztp_offer: f_21,
      you_are_flood_repeater: f_22,
      you_are_sending_too_quickly: f_23,
      instance_name: f_24,
      fabric_id: f_35,
      auto_evpn_version: f_36,
      auto_flood_reflection_version: f_40,
      auto_flood_reflection_cluster_id: f_41,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("LIEPacket");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_begin(&TFieldIdentifier::new("local_id", TType::I32, 2))?;
    o_prot.write_i32(self.local_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("flood_port", TType::I16, 3))?;
    o_prot.write_i16(self.flood_port)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.link_mtu_size {
      o_prot.write_field_begin(&TFieldIdentifier::new("link_mtu_size", TType::I32, 4))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.link_bandwidth {
      o_prot.write_field_begin(&TFieldIdentifier::new("link_bandwidth", TType::I32, 5))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.neighbor {
      o_prot.write_field_begin(&TFieldIdentifier::new("neighbor", TType::Struct, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.pod {
      o_prot.write_field_begin(&TFieldIdentifier::new("pod", TType::I32, 7))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_begin(&TFieldIdentifier::new("node_capabilities", TType::Struct, 10))?;
    self.node_capabilities.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.link_capabilities {
      o_prot.write_field_begin(&TFieldIdentifier::new("link_capabilities", TType::Struct, 11))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_begin(&TFieldIdentifier::new("holdtime", TType::I16, 12))?;
    o_prot.write_i16(self.holdtime)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.label {
      o_prot.write_field_begin(&TFieldIdentifier::new("label", TType::I32, 13))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.not_a_ztp_offer {
      o_prot.write_field_begin(&TFieldIdentifier::new("not_a_ztp_offer", TType::Bool, 21))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.you_are_flood_repeater {
      o_prot.write_field_begin(&TFieldIdentifier::new("you_are_flood_repeater", TType::Bool, 22))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.you_are_sending_too_quickly {
      o_prot.write_field_begin(&TFieldIdentifier::new("you_are_sending_too_quickly", TType::Bool, 23))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.instance_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("instance_name", TType::String, 24))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.fabric_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("fabric_id", TType::I16, 35))?;
      o_prot.write_i16(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.auto_evpn_version {
      o_prot.write_field_begin(&TFieldIdentifier::new("auto_evpn_version", TType::I16, 36))?;
      o_prot.write_i16(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.auto_flood_reflection_version {
      o_prot.write_field_begin(&TFieldIdentifier::new("auto_flood_reflection_version", TType::I16, 40))?;
      o_prot.write_i16(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.auto_flood_reflection_cluster_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("auto_flood_reflection_cluster_id", TType::I32, 41))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// LinkIDPair
//

/// LinkID pair describes one of parallel links between two nodes.
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct LinkIDPair {
  /// Node-wide unique value for the local link.
  pub local_id: common::LinkIDType,
  /// Received remote link ID for this link.
  pub remote_id: common::LinkIDType,
  /// Describes the local interface index of the link.
  pub platform_interface_index: Option<common::PlatformInterfaceIndex>,
  /// Describes the local interface name.
  pub platform_interface_name: Option<String>,
  /// Indicates whether the link is secured, i.e. protected by
  /// outer key, absence of this element means no indication,
  /// undefined outer key means not secured.
  pub trusted_outer_security_key: Option<common::OuterSecurityKeyID>,
  /// Indicates whether the link is protected by established
  /// BFD session.
  pub bfd_up: Option<bool>,
  /// Optional indication which address families are up on the
  /// interface
  pub address_families: Option<BTreeSet<common::AddressFamilyType>>,
}

impl LinkIDPair {
  pub fn new<F10, F11, F12, F13, F14>(local_id: common::LinkIDType, remote_id: common::LinkIDType, platform_interface_index: F10, platform_interface_name: F11, trusted_outer_security_key: F12, bfd_up: F13, address_families: F14) -> LinkIDPair where F10: Into<Option<common::PlatformInterfaceIndex>>, F11: Into<Option<String>>, F12: Into<Option<common::OuterSecurityKeyID>>, F13: Into<Option<bool>>, F14: Into<Option<BTreeSet<common::AddressFamilyType>>> {
    LinkIDPair {
      local_id,
      remote_id,
      platform_interface_index: platform_interface_index.into(),
      platform_interface_name: platform_interface_name.into(),
      trusted_outer_security_key: trusted_outer_security_key.into(),
      bfd_up: bfd_up.into(),
      address_families: address_families.into(),
    }
  }
}

impl TSerializable for LinkIDPair {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<LinkIDPair> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<common::LinkIDType> = None;
    let mut f_2: Option<common::LinkIDType> = None;
    let mut f_10: Option<common::PlatformInterfaceIndex> = None;
    let mut f_11: Option<String> = None;
    let mut f_12: Option<common::OuterSecurityKeyID> = None;
    let mut f_13: Option<bool> = None;
    let mut f_14: Option<BTreeSet<common::AddressFamilyType>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        10 => {
          let val = i_prot.read_i32()?;
          f_10 = Some(val);
        },
        11 => {
          let val = i_prot.read_string()?;
          f_11 = Some(val);
        },
        12 => {
          let val = i_prot.read_i8()?;
          f_12 = Some(val);
        },
        13 => {
          let val = i_prot.read_bool()?;
          f_13 = Some(val);
        },
        14 => {
          let set_ident = i_prot.read_set_begin()?;
          let mut val: BTreeSet<common::AddressFamilyType> = BTreeSet::new();
          for _ in 0..set_ident.size {
            let set_elem_0 = common::AddressFamilyType::read_from_in_protocol(i_prot)?;
            val.insert(set_elem_0);
          }
          i_prot.read_set_end()?;
          f_14 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("LinkIDPair.local_id", &f_1)?;
    verify_required_field_exists("LinkIDPair.remote_id", &f_2)?;
    let ret = LinkIDPair {
      local_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      remote_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      platform_interface_index: f_10,
      platform_interface_name: f_11,
      trusted_outer_security_key: f_12,
      bfd_up: f_13,
      address_families: f_14,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("LinkIDPair");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("local_id", TType::I32, 1))?;
    o_prot.write_i32(self.local_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("remote_id", TType::I32, 2))?;
    o_prot.write_i32(self.remote_id)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.platform_interface_index {
      o_prot.write_field_begin(&TFieldIdentifier::new("platform_interface_index", TType::I32, 10))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.platform_interface_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("platform_interface_name", TType::String, 11))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.trusted_outer_security_key {
      o_prot.write_field_begin(&TFieldIdentifier::new("trusted_outer_security_key", TType::I08, 12))?;
      o_prot.write_i8(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.bfd_up {
      o_prot.write_field_begin(&TFieldIdentifier::new("bfd_up", TType::Bool, 13))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.address_families {
      o_prot.write_field_begin(&TFieldIdentifier::new("address_families", TType::Set, 14))?;
      o_prot.write_set_begin(&TSetIdentifier::new(TType::I32, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_set_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TIEID
//

/// Unique ID of a TIE.
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TIEID {
  /// direction of TIE
  pub direction: common::TieDirectionType,
  /// indicates originator of the TIE
  pub originator: common::SystemIDType,
  /// type of the tie
  pub tietype: common::TIETypeType,
  /// number of the tie
  pub tie_nr: common::TIENrType,
}

impl TIEID {
  pub fn new(direction: common::TieDirectionType, originator: common::SystemIDType, tietype: common::TIETypeType, tie_nr: common::TIENrType) -> TIEID {
    TIEID {
      direction,
      originator,
      tietype,
      tie_nr,
    }
  }
}

impl TSerializable for TIEID {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TIEID> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<common::TieDirectionType> = None;
    let mut f_2: Option<common::SystemIDType> = None;
    let mut f_3: Option<common::TIETypeType> = None;
    let mut f_4: Option<common::TIENrType> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = common::TieDirectionType::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = common::TIETypeType::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TIEID.direction", &f_1)?;
    verify_required_field_exists("TIEID.originator", &f_2)?;
    verify_required_field_exists("TIEID.tietype", &f_3)?;
    verify_required_field_exists("TIEID.tie_nr", &f_4)?;
    let ret = TIEID {
      direction: f_1.expect("auto-generated code should have checked for presence of required fields"),
      originator: f_2.expect("auto-generated code should have checked for presence of required fields"),
      tietype: f_3.expect("auto-generated code should have checked for presence of required fields"),
      tie_nr: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TIEID");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("direction", TType::I32, 1))?;
    self.direction.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("originator", TType::I64, 2))?;
    o_prot.write_i64(self.originator)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tietype", TType::I32, 3))?;
    self.tietype.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tie_nr", TType::I32, 4))?;
    o_prot.write_i32(self.tie_nr)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TIEHeader
//

/// Header of a TIE.
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TIEHeader {
  /// ID of the tie.
  pub tieid: TIEID,
  /// Sequence number of the tie.
  pub seq_nr: common::SeqNrType,
  /// Absolute timestamp when the TIE was generated.
  pub origination_time: Option<common::IEEE8021ASTimeStampType>,
  /// Original lifetime when the TIE was generated.
  pub origination_lifetime: Option<common::LifeTimeInSecType>,
}

impl TIEHeader {
  pub fn new<F10, F12>(tieid: TIEID, seq_nr: common::SeqNrType, origination_time: F10, origination_lifetime: F12) -> TIEHeader where F10: Into<Option<common::IEEE8021ASTimeStampType>>, F12: Into<Option<common::LifeTimeInSecType>> {
    TIEHeader {
      tieid,
      seq_nr,
      origination_time: origination_time.into(),
      origination_lifetime: origination_lifetime.into(),
    }
  }
}

impl TSerializable for TIEHeader {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TIEHeader> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<TIEID> = None;
    let mut f_3: Option<common::SeqNrType> = None;
    let mut f_10: Option<common::IEEE8021ASTimeStampType> = None;
    let mut f_12: Option<common::LifeTimeInSecType> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = TIEID::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        10 => {
          let val = common::IEEE8021ASTimeStampType::read_from_in_protocol(i_prot)?;
          f_10 = Some(val);
        },
        12 => {
          let val = i_prot.read_i32()?;
          f_12 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TIEHeader.tieid", &f_2)?;
    verify_required_field_exists("TIEHeader.seq_nr", &f_3)?;
    let ret = TIEHeader {
      tieid: f_2.expect("auto-generated code should have checked for presence of required fields"),
      seq_nr: f_3.expect("auto-generated code should have checked for presence of required fields"),
      origination_time: f_10,
      origination_lifetime: f_12,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TIEHeader");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tieid", TType::Struct, 2))?;
    self.tieid.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("seq_nr", TType::I64, 3))?;
    o_prot.write_i64(self.seq_nr)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.origination_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("origination_time", TType::Struct, 10))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.origination_lifetime {
      o_prot.write_field_begin(&TFieldIdentifier::new("origination_lifetime", TType::I32, 12))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TIEHeaderWithLifeTime
//

/// Header of a TIE as described in TIRE/TIDE.
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TIEHeaderWithLifeTime {
  pub header: TIEHeader,
  /// Remaining lifetime.
  pub remaining_lifetime: common::LifeTimeInSecType,
}

impl TIEHeaderWithLifeTime {
  pub fn new(header: TIEHeader, remaining_lifetime: common::LifeTimeInSecType) -> TIEHeaderWithLifeTime {
    TIEHeaderWithLifeTime {
      header,
      remaining_lifetime,
    }
  }
}

impl TSerializable for TIEHeaderWithLifeTime {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TIEHeaderWithLifeTime> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TIEHeader> = None;
    let mut f_2: Option<common::LifeTimeInSecType> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TIEHeader::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TIEHeaderWithLifeTime.header", &f_1)?;
    verify_required_field_exists("TIEHeaderWithLifeTime.remaining_lifetime", &f_2)?;
    let ret = TIEHeaderWithLifeTime {
      header: f_1.expect("auto-generated code should have checked for presence of required fields"),
      remaining_lifetime: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TIEHeaderWithLifeTime");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("header", TType::Struct, 1))?;
    self.header.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("remaining_lifetime", TType::I32, 2))?;
    o_prot.write_i32(self.remaining_lifetime)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TIDEPacket
//

/// TIDE with *sorted* TIE headers.
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TIDEPacket {
  /// First TIE header in the tide packet.
  pub start_range: TIEID,
  /// Last TIE header in the tide packet.
  pub end_range: TIEID,
  /// _Sorted_ list of headers.
  pub headers: Vec<TIEHeaderWithLifeTime>,
}

impl TIDEPacket {
  pub fn new(start_range: TIEID, end_range: TIEID, headers: Vec<TIEHeaderWithLifeTime>) -> TIDEPacket {
    TIDEPacket {
      start_range,
      end_range,
      headers,
    }
  }
}

impl TSerializable for TIDEPacket {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TIDEPacket> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TIEID> = None;
    let mut f_2: Option<TIEID> = None;
    let mut f_3: Option<Vec<TIEHeaderWithLifeTime>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TIEID::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = TIEID::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TIEHeaderWithLifeTime> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_1 = TIEHeaderWithLifeTime::read_from_in_protocol(i_prot)?;
            val.push(list_elem_1);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TIDEPacket.start_range", &f_1)?;
    verify_required_field_exists("TIDEPacket.end_range", &f_2)?;
    verify_required_field_exists("TIDEPacket.headers", &f_3)?;
    let ret = TIDEPacket {
      start_range: f_1.expect("auto-generated code should have checked for presence of required fields"),
      end_range: f_2.expect("auto-generated code should have checked for presence of required fields"),
      headers: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TIDEPacket");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("start_range", TType::Struct, 1))?;
    self.start_range.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("end_range", TType::Struct, 2))?;
    self.end_range.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("headers", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.headers.len() as i32))?;
    for e in &self.headers {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TIREPacket
//

/// TIRE packet
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TIREPacket {
  pub headers: BTreeSet<TIEHeaderWithLifeTime>,
}

impl TIREPacket {
  pub fn new(headers: BTreeSet<TIEHeaderWithLifeTime>) -> TIREPacket {
    TIREPacket {
      headers,
    }
  }
}

impl TSerializable for TIREPacket {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TIREPacket> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<BTreeSet<TIEHeaderWithLifeTime>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let set_ident = i_prot.read_set_begin()?;
          let mut val: BTreeSet<TIEHeaderWithLifeTime> = BTreeSet::new();
          for _ in 0..set_ident.size {
            let set_elem_2 = TIEHeaderWithLifeTime::read_from_in_protocol(i_prot)?;
            val.insert(set_elem_2);
          }
          i_prot.read_set_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TIREPacket.headers", &f_1)?;
    let ret = TIREPacket {
      headers: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TIREPacket");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("headers", TType::Set, 1))?;
    o_prot.write_set_begin(&TSetIdentifier::new(TType::Struct, self.headers.len() as i32))?;
    for e in &self.headers {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_set_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NodeNeighborsTIEElement
//

/// neighbor of a node
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NodeNeighborsTIEElement {
  /// level of neighbor
  pub level: common::LevelType,
  /// Cost to neighbor. Ignore anything larger than `infinite_distance` and `invalid_distance`
  pub cost: Option<common::MetricType>,
  /// can carry description of multiple parallel links in a TIE
  pub link_ids: Option<BTreeSet<LinkIDPair>>,
  /// total bandwith to neighbor as sum of all parallel links
  pub bandwidth: Option<common::BandwithInMegaBitsType>,
}

impl NodeNeighborsTIEElement {
  pub fn new<F3, F4, F5>(level: common::LevelType, cost: F3, link_ids: F4, bandwidth: F5) -> NodeNeighborsTIEElement where F3: Into<Option<common::MetricType>>, F4: Into<Option<BTreeSet<LinkIDPair>>>, F5: Into<Option<common::BandwithInMegaBitsType>> {
    NodeNeighborsTIEElement {
      level,
      cost: cost.into(),
      link_ids: link_ids.into(),
      bandwidth: bandwidth.into(),
    }
  }
}

impl TSerializable for NodeNeighborsTIEElement {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NodeNeighborsTIEElement> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<common::LevelType> = None;
    let mut f_3: Option<common::MetricType> = None;
    let mut f_4: Option<BTreeSet<LinkIDPair>> = None;
    let mut f_5: Option<common::BandwithInMegaBitsType> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i8()?;
          f_1 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let set_ident = i_prot.read_set_begin()?;
          let mut val: BTreeSet<LinkIDPair> = BTreeSet::new();
          for _ in 0..set_ident.size {
            let set_elem_3 = LinkIDPair::read_from_in_protocol(i_prot)?;
            val.insert(set_elem_3);
          }
          i_prot.read_set_end()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NodeNeighborsTIEElement.level", &f_1)?;
    let ret = NodeNeighborsTIEElement {
      level: f_1.expect("auto-generated code should have checked for presence of required fields"),
      cost: f_3,
      link_ids: f_4,
      bandwidth: f_5,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NodeNeighborsTIEElement");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("level", TType::I08, 1))?;
    o_prot.write_i8(self.level)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.cost {
      o_prot.write_field_begin(&TFieldIdentifier::new("cost", TType::I32, 3))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.link_ids {
      o_prot.write_field_begin(&TFieldIdentifier::new("link_ids", TType::Set, 4))?;
      o_prot.write_set_begin(&TSetIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_set_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.bandwidth {
      o_prot.write_field_begin(&TFieldIdentifier::new("bandwidth", TType::I32, 5))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NodeFlags
//

/// Indication flags of the node.
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NodeFlags {
  /// Indicates that node is in overload, do not transit traffic
  /// through it.
  pub overload: Option<bool>,
  /// acting as DCI for auto-evpn, necessary for proper RR election where DCIs are preferred
  pub acting_auto_evpn_dci_when_tof: Option<bool>,
}

impl NodeFlags {
  pub fn new<F1, F10>(overload: F1, acting_auto_evpn_dci_when_tof: F10) -> NodeFlags where F1: Into<Option<bool>>, F10: Into<Option<bool>> {
    NodeFlags {
      overload: overload.into(),
      acting_auto_evpn_dci_when_tof: acting_auto_evpn_dci_when_tof.into(),
    }
  }
}

impl TSerializable for NodeFlags {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NodeFlags> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    let mut f_10: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        10 => {
          let val = i_prot.read_bool()?;
          f_10 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NodeFlags {
      overload: f_1,
      acting_auto_evpn_dci_when_tof: f_10,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NodeFlags");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.overload {
      o_prot.write_field_begin(&TFieldIdentifier::new("overload", TType::Bool, 1))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.acting_auto_evpn_dci_when_tof {
      o_prot.write_field_begin(&TFieldIdentifier::new("acting_auto_evpn_dci_when_tof", TType::Bool, 10))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for NodeFlags {
  fn default() -> Self {
    NodeFlags{
      overload: Some(false),
      acting_auto_evpn_dci_when_tof: Some(false),
    }
  }
}

//
// NodeTIEElement
//

/// Description of a node.
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NodeTIEElement {
  /// Level of the node.
  pub level: common::LevelType,
  /// Node's neighbors. Multiple node TIEs can carry disjoint sets of neighbors.
  pub neighbors: BTreeMap<common::SystemIDType, NodeNeighborsTIEElement>,
  /// Capabilities of the node.
  pub capabilities: NodeCapabilities,
  /// Flags of the node.
  pub flags: Option<NodeFlags>,
  /// Optional node name for easier operations.
  pub name: Option<String>,
  /// PoD to which the node belongs.
  pub pod: Option<common::PodType>,
  /// optional startup time of the node
  pub startup_time: Option<common::TimestampInSecsType>,
  /// If any local links are miscabled, this indication is flooded.
  pub miscabled_links: Option<BTreeSet<common::LinkIDType>>,
  /// ToFs in the same plane. Only carried by ToF. Multiple node TIEs can carry disjoint sets of ToFs
  /// which can be joined to form a single set. Used in complex multi-plane elections.
  pub same_plane_tofs: Option<BTreeSet<common::SystemIDType>>,
  /// It provides optional version of EVPN ZTP as 256 * MAJOR + MINOR, if set auto EVPN is enabled.
  pub auto_evpn_version: Option<i16>,
  /// It provides the optional ID of the Fabric configured
  pub fabric_id: Option<common::FabricIDType>,
  /// provides optionally the EVPN model supported
  pub auto_evpn_model: Option<common::AutoEVPNModel>,
  /// It provides optional version of FR ZTP as 256 * MAJOR + MINOR, if set indicates auto FR is enabled.
  pub auto_flood_reflection_version: Option<i16>,
  /// cluster ID of Auto FR
  pub auto_flood_reflection_cluster_id: Option<common::FloodReflectionClusterIDType>,
  /// preference to become FR, if not set it indicates that the node cannot perform flood reflection role
  pub auto_flood_reflection_preference: Option<common::FloodReflectionPreferenceType>,
}

impl NodeTIEElement {
  pub fn new<F4, F5, F6, F7, F10, F12, F21, F22, F25, F30, F31, F32>(level: common::LevelType, neighbors: BTreeMap<common::SystemIDType, NodeNeighborsTIEElement>, capabilities: NodeCapabilities, flags: F4, name: F5, pod: F6, startup_time: F7, miscabled_links: F10, same_plane_tofs: F12, auto_evpn_version: F21, fabric_id: F22, auto_evpn_model: F25, auto_flood_reflection_version: F30, auto_flood_reflection_cluster_id: F31, auto_flood_reflection_preference: F32) -> NodeTIEElement where F4: Into<Option<NodeFlags>>, F5: Into<Option<String>>, F6: Into<Option<common::PodType>>, F7: Into<Option<common::TimestampInSecsType>>, F10: Into<Option<BTreeSet<common::LinkIDType>>>, F12: Into<Option<BTreeSet<common::SystemIDType>>>, F21: Into<Option<i16>>, F22: Into<Option<common::FabricIDType>>, F25: Into<Option<common::AutoEVPNModel>>, F30: Into<Option<i16>>, F31: Into<Option<common::FloodReflectionClusterIDType>>, F32: Into<Option<common::FloodReflectionPreferenceType>> {
    NodeTIEElement {
      level,
      neighbors,
      capabilities,
      flags: flags.into(),
      name: name.into(),
      pod: pod.into(),
      startup_time: startup_time.into(),
      miscabled_links: miscabled_links.into(),
      same_plane_tofs: same_plane_tofs.into(),
      auto_evpn_version: auto_evpn_version.into(),
      fabric_id: fabric_id.into(),
      auto_evpn_model: auto_evpn_model.into(),
      auto_flood_reflection_version: auto_flood_reflection_version.into(),
      auto_flood_reflection_cluster_id: auto_flood_reflection_cluster_id.into(),
      auto_flood_reflection_preference: auto_flood_reflection_preference.into(),
    }
  }
}

impl TSerializable for NodeTIEElement {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NodeTIEElement> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<common::LevelType> = None;
    let mut f_2: Option<BTreeMap<common::SystemIDType, NodeNeighborsTIEElement>> = None;
    let mut f_3: Option<NodeCapabilities> = None;
    let mut f_4: Option<NodeFlags> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<common::PodType> = None;
    let mut f_7: Option<common::TimestampInSecsType> = None;
    let mut f_10: Option<BTreeSet<common::LinkIDType>> = None;
    let mut f_12: Option<BTreeSet<common::SystemIDType>> = None;
    let mut f_21: Option<i16> = None;
    let mut f_22: Option<common::FabricIDType> = None;
    let mut f_25: Option<common::AutoEVPNModel> = None;
    let mut f_30: Option<i16> = None;
    let mut f_31: Option<common::FloodReflectionClusterIDType> = None;
    let mut f_32: Option<common::FloodReflectionPreferenceType> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i8()?;
          f_1 = Some(val);
        },
        2 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<common::SystemIDType, NodeNeighborsTIEElement> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_4 = i_prot.read_i64()?;
            let map_val_5 = NodeNeighborsTIEElement::read_from_in_protocol(i_prot)?;
            val.insert(map_key_4, map_val_5);
          }
          i_prot.read_map_end()?;
          f_2 = Some(val);
        },
        3 => {
          let val = NodeCapabilities::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = NodeFlags::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i64()?;
          f_7 = Some(val);
        },
        10 => {
          let set_ident = i_prot.read_set_begin()?;
          let mut val: BTreeSet<common::LinkIDType> = BTreeSet::new();
          for _ in 0..set_ident.size {
            let set_elem_6 = i_prot.read_i32()?;
            val.insert(set_elem_6);
          }
          i_prot.read_set_end()?;
          f_10 = Some(val);
        },
        12 => {
          let set_ident = i_prot.read_set_begin()?;
          let mut val: BTreeSet<common::SystemIDType> = BTreeSet::new();
          for _ in 0..set_ident.size {
            let set_elem_7 = i_prot.read_i64()?;
            val.insert(set_elem_7);
          }
          i_prot.read_set_end()?;
          f_12 = Some(val);
        },
        21 => {
          let val = i_prot.read_i16()?;
          f_21 = Some(val);
        },
        22 => {
          let val = i_prot.read_i16()?;
          f_22 = Some(val);
        },
        25 => {
          let val = common::AutoEVPNModel::read_from_in_protocol(i_prot)?;
          f_25 = Some(val);
        },
        30 => {
          let val = i_prot.read_i16()?;
          f_30 = Some(val);
        },
        31 => {
          let val = i_prot.read_i32()?;
          f_31 = Some(val);
        },
        32 => {
          let val = i_prot.read_i32()?;
          f_32 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NodeTIEElement.level", &f_1)?;
    verify_required_field_exists("NodeTIEElement.neighbors", &f_2)?;
    verify_required_field_exists("NodeTIEElement.capabilities", &f_3)?;
    let ret = NodeTIEElement {
      level: f_1.expect("auto-generated code should have checked for presence of required fields"),
      neighbors: f_2.expect("auto-generated code should have checked for presence of required fields"),
      capabilities: f_3.expect("auto-generated code should have checked for presence of required fields"),
      flags: f_4,
      name: f_5,
      pod: f_6,
      startup_time: f_7,
      miscabled_links: f_10,
      same_plane_tofs: f_12,
      auto_evpn_version: f_21,
      fabric_id: f_22,
      auto_evpn_model: f_25,
      auto_flood_reflection_version: f_30,
      auto_flood_reflection_cluster_id: f_31,
      auto_flood_reflection_preference: f_32,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NodeTIEElement");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("level", TType::I08, 1))?;
    o_prot.write_i8(self.level)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("neighbors", TType::Map, 2))?;
    o_prot.write_map_begin(&TMapIdentifier::new(TType::I64, TType::Struct, self.neighbors.len() as i32))?;
    for (k, v) in &self.neighbors {
      o_prot.write_i64(*k)?;
      v.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_map_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("capabilities", TType::Struct, 3))?;
    self.capabilities.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.flags {
      o_prot.write_field_begin(&TFieldIdentifier::new("flags", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.pod {
      o_prot.write_field_begin(&TFieldIdentifier::new("pod", TType::I32, 6))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.startup_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("startup_time", TType::I64, 7))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.miscabled_links {
      o_prot.write_field_begin(&TFieldIdentifier::new("miscabled_links", TType::Set, 10))?;
      o_prot.write_set_begin(&TSetIdentifier::new(TType::I32, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_i32(*e)?;
      }
      o_prot.write_set_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.same_plane_tofs {
      o_prot.write_field_begin(&TFieldIdentifier::new("same_plane_tofs", TType::Set, 12))?;
      o_prot.write_set_begin(&TSetIdentifier::new(TType::I64, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_i64(*e)?;
      }
      o_prot.write_set_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.auto_evpn_version {
      o_prot.write_field_begin(&TFieldIdentifier::new("auto_evpn_version", TType::I16, 21))?;
      o_prot.write_i16(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.fabric_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("fabric_id", TType::I16, 22))?;
      o_prot.write_i16(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.auto_evpn_model {
      o_prot.write_field_begin(&TFieldIdentifier::new("auto_evpn_model", TType::I32, 25))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.auto_flood_reflection_version {
      o_prot.write_field_begin(&TFieldIdentifier::new("auto_flood_reflection_version", TType::I16, 30))?;
      o_prot.write_i16(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.auto_flood_reflection_cluster_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("auto_flood_reflection_cluster_id", TType::I32, 31))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.auto_flood_reflection_preference {
      o_prot.write_field_begin(&TFieldIdentifier::new("auto_flood_reflection_preference", TType::I32, 32))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// PrefixAttributes
//

/// Attributes of a prefix.
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct PrefixAttributes {
  /// Distance of the prefix.
  pub metric: common::MetricType,
  /// Generic unordered set of route tags, can be redistributed
  /// to other protocols or use within the context of real time
  /// analytics.
  pub tags: Option<BTreeSet<common::RouteTagType>>,
  /// Monotonic clock for mobile addresses.
  pub monotonic_clock: Option<common::PrefixSequenceType>,
  /// Indicates if the prefix is a node loopback.
  pub loopback: Option<bool>,
  /// Indicates that the prefix is directly attached.
  pub directly_attached: Option<bool>,
  /// link to which the address belongs to.
  pub from_link: Option<common::LinkIDType>,
  /// Optional, per prefix significant label.
  pub label: Option<common::LabelType>,
}

impl PrefixAttributes {
  pub fn new<F3, F4, F6, F7, F10, F12>(metric: common::MetricType, tags: F3, monotonic_clock: F4, loopback: F6, directly_attached: F7, from_link: F10, label: F12) -> PrefixAttributes where F3: Into<Option<BTreeSet<common::RouteTagType>>>, F4: Into<Option<common::PrefixSequenceType>>, F6: Into<Option<bool>>, F7: Into<Option<bool>>, F10: Into<Option<common::LinkIDType>>, F12: Into<Option<common::LabelType>> {
    PrefixAttributes {
      metric,
      tags: tags.into(),
      monotonic_clock: monotonic_clock.into(),
      loopback: loopback.into(),
      directly_attached: directly_attached.into(),
      from_link: from_link.into(),
      label: label.into(),
    }
  }
}

impl TSerializable for PrefixAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<PrefixAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<common::MetricType> = None;
    let mut f_3: Option<BTreeSet<common::RouteTagType>> = None;
    let mut f_4: Option<common::PrefixSequenceType> = None;
    let mut f_6: Option<bool> = None;
    let mut f_7: Option<bool> = None;
    let mut f_10: Option<common::LinkIDType> = None;
    let mut f_12: Option<common::LabelType> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let set_ident = i_prot.read_set_begin()?;
          let mut val: BTreeSet<common::RouteTagType> = BTreeSet::new();
          for _ in 0..set_ident.size {
            let set_elem_8 = i_prot.read_i64()?;
            val.insert(set_elem_8);
          }
          i_prot.read_set_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = common::PrefixSequenceType::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_bool()?;
          f_7 = Some(val);
        },
        10 => {
          let val = i_prot.read_i32()?;
          f_10 = Some(val);
        },
        12 => {
          let val = i_prot.read_i32()?;
          f_12 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("PrefixAttributes.metric", &f_2)?;
    let ret = PrefixAttributes {
      metric: f_2.expect("auto-generated code should have checked for presence of required fields"),
      tags: f_3,
      monotonic_clock: f_4,
      loopback: f_6,
      directly_attached: f_7,
      from_link: f_10,
      label: f_12,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PrefixAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("metric", TType::I32, 2))?;
    o_prot.write_i32(self.metric)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.tags {
      o_prot.write_field_begin(&TFieldIdentifier::new("tags", TType::Set, 3))?;
      o_prot.write_set_begin(&TSetIdentifier::new(TType::I64, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_i64(*e)?;
      }
      o_prot.write_set_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.monotonic_clock {
      o_prot.write_field_begin(&TFieldIdentifier::new("monotonic_clock", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.loopback {
      o_prot.write_field_begin(&TFieldIdentifier::new("loopback", TType::Bool, 6))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.directly_attached {
      o_prot.write_field_begin(&TFieldIdentifier::new("directly_attached", TType::Bool, 7))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.from_link {
      o_prot.write_field_begin(&TFieldIdentifier::new("from_link", TType::I32, 10))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.label {
      o_prot.write_field_begin(&TFieldIdentifier::new("label", TType::I32, 12))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// PrefixTIEElement
//

/// TIE carrying prefixes
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct PrefixTIEElement {
  /// Prefixes with the associated attributes.
  pub prefixes: BTreeMap<common::IPPrefixType, PrefixAttributes>,
}

impl PrefixTIEElement {
  pub fn new(prefixes: BTreeMap<common::IPPrefixType, PrefixAttributes>) -> PrefixTIEElement {
    PrefixTIEElement {
      prefixes,
    }
  }
}

impl TSerializable for PrefixTIEElement {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<PrefixTIEElement> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<BTreeMap<common::IPPrefixType, PrefixAttributes>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<common::IPPrefixType, PrefixAttributes> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_9 = common::IPPrefixType::read_from_in_protocol(i_prot)?;
            let map_val_10 = PrefixAttributes::read_from_in_protocol(i_prot)?;
            val.insert(map_key_9, map_val_10);
          }
          i_prot.read_map_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("PrefixTIEElement.prefixes", &f_1)?;
    let ret = PrefixTIEElement {
      prefixes: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PrefixTIEElement");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("prefixes", TType::Map, 1))?;
    o_prot.write_map_begin(&TMapIdentifier::new(TType::Struct, TType::Struct, self.prefixes.len() as i32))?;
    for (k, v) in &self.prefixes {
      k.write_to_out_protocol(o_prot)?;
      v.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_map_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// KeyValueTIEElement
//

/// Generic key value pairs.
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct KeyValueTIEElement {
  pub keyvalues: BTreeMap<common::KeyIDType, Vec<u8>>,
}

impl KeyValueTIEElement {
  pub fn new(keyvalues: BTreeMap<common::KeyIDType, Vec<u8>>) -> KeyValueTIEElement {
    KeyValueTIEElement {
      keyvalues,
    }
  }
}

impl TSerializable for KeyValueTIEElement {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<KeyValueTIEElement> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<BTreeMap<common::KeyIDType, Vec<u8>>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<common::KeyIDType, Vec<u8>> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_11 = i_prot.read_i32()?;
            let map_val_12 = i_prot.read_bytes()?;
            val.insert(map_key_11, map_val_12);
          }
          i_prot.read_map_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("KeyValueTIEElement.keyvalues", &f_1)?;
    let ret = KeyValueTIEElement {
      keyvalues: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("KeyValueTIEElement");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("keyvalues", TType::Map, 1))?;
    o_prot.write_map_begin(&TMapIdentifier::new(TType::I32, TType::String, self.keyvalues.len() as i32))?;
    for (k, v) in &self.keyvalues {
      o_prot.write_i32(*k)?;
      o_prot.write_bytes(v)?;
    }
    o_prot.write_map_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TIEElement
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum TIEElement {
  Node(NodeTIEElement),
  Prefixes(PrefixTIEElement),
  PositiveDisaggregationPrefixes(PrefixTIEElement),
  NegativeDisaggregationPrefixes(PrefixTIEElement),
  ExternalPrefixes(PrefixTIEElement),
  PositiveExternalDisaggregationPrefixes(PrefixTIEElement),
  Keyvalues(KeyValueTIEElement),
}

impl TSerializable for TIEElement {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TIEElement> {
    let mut ret: Option<TIEElement> = None;
    let mut received_field_count = 0;
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = NodeTIEElement::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(TIEElement::Node(val));
          }
          received_field_count += 1;
        },
        2 => {
          let val = PrefixTIEElement::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(TIEElement::Prefixes(val));
          }
          received_field_count += 1;
        },
        3 => {
          let val = PrefixTIEElement::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(TIEElement::PositiveDisaggregationPrefixes(val));
          }
          received_field_count += 1;
        },
        5 => {
          let val = PrefixTIEElement::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(TIEElement::NegativeDisaggregationPrefixes(val));
          }
          received_field_count += 1;
        },
        6 => {
          let val = PrefixTIEElement::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(TIEElement::ExternalPrefixes(val));
          }
          received_field_count += 1;
        },
        7 => {
          let val = PrefixTIEElement::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(TIEElement::PositiveExternalDisaggregationPrefixes(val));
          }
          received_field_count += 1;
        },
        9 => {
          let val = KeyValueTIEElement::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(TIEElement::Keyvalues(val));
          }
          received_field_count += 1;
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
          received_field_count += 1;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    if received_field_count == 0 {
      Err(
        thrift::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorKind::InvalidData,
            "received empty union from remote TIEElement"
          )
        )
      )
    } else if received_field_count > 1 {
      Err(
        thrift::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorKind::InvalidData,
            "received multiple fields for union from remote TIEElement"
          )
        )
      )
    } else {
      Ok(ret.expect("return value should have been constructed"))
    }
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TIEElement");
    o_prot.write_struct_begin(&struct_ident)?;
    match *self {
      TIEElement::Node(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("node", TType::Struct, 1))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      TIEElement::Prefixes(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("prefixes", TType::Struct, 2))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      TIEElement::PositiveDisaggregationPrefixes(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("positive_disaggregation_prefixes", TType::Struct, 3))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      TIEElement::NegativeDisaggregationPrefixes(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("negative_disaggregation_prefixes", TType::Struct, 5))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      TIEElement::ExternalPrefixes(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("external_prefixes", TType::Struct, 6))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      TIEElement::PositiveExternalDisaggregationPrefixes(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("positive_external_disaggregation_prefixes", TType::Struct, 7))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      TIEElement::Keyvalues(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("keyvalues", TType::Struct, 9))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TIEPacket
//

/// TIE packet
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TIEPacket {
  pub header: TIEHeader,
  pub element: TIEElement,
}

impl TIEPacket {
  pub fn new(header: TIEHeader, element: TIEElement) -> TIEPacket {
    TIEPacket {
      header,
      element,
    }
  }
}

impl TSerializable for TIEPacket {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TIEPacket> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TIEHeader> = None;
    let mut f_2: Option<TIEElement> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TIEHeader::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = TIEElement::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TIEPacket.header", &f_1)?;
    verify_required_field_exists("TIEPacket.element", &f_2)?;
    let ret = TIEPacket {
      header: f_1.expect("auto-generated code should have checked for presence of required fields"),
      element: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TIEPacket");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("header", TType::Struct, 1))?;
    self.header.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("element", TType::Struct, 2))?;
    self.element.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// PacketContent
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum PacketContent {
  Lie(LIEPacket),
  Tide(TIDEPacket),
  Tire(TIREPacket),
  Tie(TIEPacket),
}

impl TSerializable for PacketContent {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<PacketContent> {
    let mut ret: Option<PacketContent> = None;
    let mut received_field_count = 0;
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = LIEPacket::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(PacketContent::Lie(val));
          }
          received_field_count += 1;
        },
        2 => {
          let val = TIDEPacket::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(PacketContent::Tide(val));
          }
          received_field_count += 1;
        },
        3 => {
          let val = TIREPacket::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(PacketContent::Tire(val));
          }
          received_field_count += 1;
        },
        4 => {
          let val = TIEPacket::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(PacketContent::Tie(val));
          }
          received_field_count += 1;
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
          received_field_count += 1;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    if received_field_count == 0 {
      Err(
        thrift::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorKind::InvalidData,
            "received empty union from remote PacketContent"
          )
        )
      )
    } else if received_field_count > 1 {
      Err(
        thrift::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorKind::InvalidData,
            "received multiple fields for union from remote PacketContent"
          )
        )
      )
    } else {
      Ok(ret.expect("return value should have been constructed"))
    }
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PacketContent");
    o_prot.write_struct_begin(&struct_ident)?;
    match *self {
      PacketContent::Lie(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("lie", TType::Struct, 1))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      PacketContent::Tide(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("tide", TType::Struct, 2))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      PacketContent::Tire(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("tire", TType::Struct, 3))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      PacketContent::Tie(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("tie", TType::Struct, 4))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ProtocolPacket
//

/// RIFT packet structure.
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ProtocolPacket {
  pub header: PacketHeader,
  pub content: PacketContent,
}

impl ProtocolPacket {
  pub fn new(header: PacketHeader, content: PacketContent) -> ProtocolPacket {
    ProtocolPacket {
      header,
      content,
    }
  }
}

impl TSerializable for ProtocolPacket {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ProtocolPacket> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<PacketHeader> = None;
    let mut f_2: Option<PacketContent> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = PacketHeader::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = PacketContent::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ProtocolPacket.header", &f_1)?;
    verify_required_field_exists("ProtocolPacket.content", &f_2)?;
    let ret = ProtocolPacket {
      header: f_1.expect("auto-generated code should have checked for presence of required fields"),
      content: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ProtocolPacket");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("header", TType::Struct, 1))?;
    self.header.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("content", TType::Struct, 2))?;
    self.content.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

pub const PROTOCOL_MAJOR_VERSION: common::VersionType = 6;

pub const PROTOCOL_MINOR_VERSION: common::MinorVersionType = 1;

