// Autogenerated by Thrift Compiler (0.17.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

#![allow(unused_imports)]
#![allow(unused_extern_crates)]
#![allow(clippy::too_many_arguments, clippy::type_complexity, clippy::vec_box)]
#![cfg_attr(rustfmt, rustfmt_skip)]

use std::cell::RefCell;
use std::collections::{BTreeMap, BTreeSet};
use std::convert::{From, TryFrom};
use std::default::Default;
use std::error::Error;
use std::fmt;
use std::fmt::{Display, Formatter};
use std::rc::Rc;

use thrift::OrderedFloat;
use thrift::{ApplicationError, ApplicationErrorKind, ProtocolError, ProtocolErrorKind, TThriftClient};
use thrift::protocol::{TFieldIdentifier, TListIdentifier, TMapIdentifier, TMessageIdentifier, TMessageType, TInputProtocol, TOutputProtocol, TSerializable, TSetIdentifier, TStructIdentifier, TType};
use thrift::protocol::field_id;
use thrift::protocol::verify_expected_message_type;
use thrift::protocol::verify_expected_sequence_number;
use thrift::protocol::verify_expected_service_call;
use thrift::protocol::verify_required_field_exists;
use thrift::server::TProcessor;

/// Flags indicating node configuration in case of ZTP.
#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct HierarchyIndications(pub i32);

impl HierarchyIndications {
  /// forces level to `leaf_level` and enables according procedures
  pub const LEAF_ONLY: HierarchyIndications = HierarchyIndications(0);
  /// forces level to `leaf_level` and enables according procedures
  pub const LEAF_ONLY_AND_LEAF_2_LEAF_PROCEDURES: HierarchyIndications = HierarchyIndications(1);
  /// forces level to `top_of_fabric` and enables according
  /// procedures
  pub const TOP_OF_FABRIC: HierarchyIndications = HierarchyIndications(2);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::LEAF_ONLY,
    Self::LEAF_ONLY_AND_LEAF_2_LEAF_PROCEDURES,
    Self::TOP_OF_FABRIC,
  ];
}

impl TSerializable for HierarchyIndications {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HierarchyIndications> {
    let enum_value = i_prot.read_i32()?;
    Ok(HierarchyIndications::from(enum_value))
  }
}

impl From<i32> for HierarchyIndications {
  fn from(i: i32) -> Self {
    match i {
      0 => HierarchyIndications::LEAF_ONLY,
      1 => HierarchyIndications::LEAF_ONLY_AND_LEAF_2_LEAF_PROCEDURES,
      2 => HierarchyIndications::TOP_OF_FABRIC,
      _ => HierarchyIndications(i)
    }
  }
}

impl From<&i32> for HierarchyIndications {
  fn from(i: &i32) -> Self {
    HierarchyIndications::from(*i)
  }
}

impl From<HierarchyIndications> for i32 {
  fn from(e: HierarchyIndications) -> i32 {
    e.0
  }
}

impl From<&HierarchyIndications> for i32 {
  fn from(e: &HierarchyIndications) -> i32 {
    e.0
  }
}

/// Direction of TIEs.
#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TieDirectionType(pub i32);

impl TieDirectionType {
  pub const ILLEGAL: TieDirectionType = TieDirectionType(0);
  pub const SOUTH: TieDirectionType = TieDirectionType(1);
  pub const NORTH: TieDirectionType = TieDirectionType(2);
  pub const DIRECTION_MAX_VALUE: TieDirectionType = TieDirectionType(3);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::ILLEGAL,
    Self::SOUTH,
    Self::NORTH,
    Self::DIRECTION_MAX_VALUE,
  ];
}

impl TSerializable for TieDirectionType {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TieDirectionType> {
    let enum_value = i_prot.read_i32()?;
    Ok(TieDirectionType::from(enum_value))
  }
}

impl From<i32> for TieDirectionType {
  fn from(i: i32) -> Self {
    match i {
      0 => TieDirectionType::ILLEGAL,
      1 => TieDirectionType::SOUTH,
      2 => TieDirectionType::NORTH,
      3 => TieDirectionType::DIRECTION_MAX_VALUE,
      _ => TieDirectionType(i)
    }
  }
}

impl From<&i32> for TieDirectionType {
  fn from(i: &i32) -> Self {
    TieDirectionType::from(*i)
  }
}

impl From<TieDirectionType> for i32 {
  fn from(e: TieDirectionType) -> i32 {
    e.0
  }
}

impl From<&TieDirectionType> for i32 {
  fn from(e: &TieDirectionType) -> i32 {
    e.0
  }
}

/// Address family type.
#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct AddressFamilyType(pub i32);

impl AddressFamilyType {
  pub const ILLEGAL: AddressFamilyType = AddressFamilyType(0);
  pub const ADDRESS_FAMILY_MIN_VALUE: AddressFamilyType = AddressFamilyType(1);
  pub const I_PV4: AddressFamilyType = AddressFamilyType(2);
  pub const I_PV6: AddressFamilyType = AddressFamilyType(3);
  pub const ADDRESS_FAMILY_MAX_VALUE: AddressFamilyType = AddressFamilyType(4);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::ILLEGAL,
    Self::ADDRESS_FAMILY_MIN_VALUE,
    Self::I_PV4,
    Self::I_PV6,
    Self::ADDRESS_FAMILY_MAX_VALUE,
  ];
}

impl TSerializable for AddressFamilyType {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<AddressFamilyType> {
    let enum_value = i_prot.read_i32()?;
    Ok(AddressFamilyType::from(enum_value))
  }
}

impl From<i32> for AddressFamilyType {
  fn from(i: i32) -> Self {
    match i {
      0 => AddressFamilyType::ILLEGAL,
      1 => AddressFamilyType::ADDRESS_FAMILY_MIN_VALUE,
      2 => AddressFamilyType::I_PV4,
      3 => AddressFamilyType::I_PV6,
      4 => AddressFamilyType::ADDRESS_FAMILY_MAX_VALUE,
      _ => AddressFamilyType(i)
    }
  }
}

impl From<&i32> for AddressFamilyType {
  fn from(i: &i32) -> Self {
    AddressFamilyType::from(*i)
  }
}

impl From<AddressFamilyType> for i32 {
  fn from(e: AddressFamilyType) -> i32 {
    e.0
  }
}

impl From<&AddressFamilyType> for i32 {
  fn from(e: &AddressFamilyType) -> i32 {
    e.0
  }
}

/// Type of TIE.
#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TIETypeType(pub i32);

impl TIETypeType {
  pub const ILLEGAL: TIETypeType = TIETypeType(0);
  pub const T_I_E_TYPE_MIN_VALUE: TIETypeType = TIETypeType(1);
  /// first legal value
  pub const NODE_T_I_E_TYPE: TIETypeType = TIETypeType(2);
  pub const PREFIX_T_I_E_TYPE: TIETypeType = TIETypeType(3);
  pub const POSITIVE_DISAGGREGATION_PREFIX_T_I_E_TYPE: TIETypeType = TIETypeType(4);
  pub const NEGATIVE_DISAGGREGATION_PREFIX_T_I_E_TYPE: TIETypeType = TIETypeType(5);
  pub const P_G_PREFIX_T_I_E_TYPE: TIETypeType = TIETypeType(6);
  pub const KEY_VALUE_T_I_E_TYPE: TIETypeType = TIETypeType(7);
  pub const EXTERNAL_PREFIX_T_I_E_TYPE: TIETypeType = TIETypeType(8);
  pub const POSITIVE_EXTERNAL_DISAGGREGATION_PREFIX_T_I_E_TYPE: TIETypeType = TIETypeType(9);
  pub const T_I_E_TYPE_MAX_VALUE: TIETypeType = TIETypeType(10);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::ILLEGAL,
    Self::T_I_E_TYPE_MIN_VALUE,
    Self::NODE_T_I_E_TYPE,
    Self::PREFIX_T_I_E_TYPE,
    Self::POSITIVE_DISAGGREGATION_PREFIX_T_I_E_TYPE,
    Self::NEGATIVE_DISAGGREGATION_PREFIX_T_I_E_TYPE,
    Self::P_G_PREFIX_T_I_E_TYPE,
    Self::KEY_VALUE_T_I_E_TYPE,
    Self::EXTERNAL_PREFIX_T_I_E_TYPE,
    Self::POSITIVE_EXTERNAL_DISAGGREGATION_PREFIX_T_I_E_TYPE,
    Self::T_I_E_TYPE_MAX_VALUE,
  ];
}

impl TSerializable for TIETypeType {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TIETypeType> {
    let enum_value = i_prot.read_i32()?;
    Ok(TIETypeType::from(enum_value))
  }
}

impl From<i32> for TIETypeType {
  fn from(i: i32) -> Self {
    match i {
      0 => TIETypeType::ILLEGAL,
      1 => TIETypeType::T_I_E_TYPE_MIN_VALUE,
      2 => TIETypeType::NODE_T_I_E_TYPE,
      3 => TIETypeType::PREFIX_T_I_E_TYPE,
      4 => TIETypeType::POSITIVE_DISAGGREGATION_PREFIX_T_I_E_TYPE,
      5 => TIETypeType::NEGATIVE_DISAGGREGATION_PREFIX_T_I_E_TYPE,
      6 => TIETypeType::P_G_PREFIX_T_I_E_TYPE,
      7 => TIETypeType::KEY_VALUE_T_I_E_TYPE,
      8 => TIETypeType::EXTERNAL_PREFIX_T_I_E_TYPE,
      9 => TIETypeType::POSITIVE_EXTERNAL_DISAGGREGATION_PREFIX_T_I_E_TYPE,
      10 => TIETypeType::T_I_E_TYPE_MAX_VALUE,
      _ => TIETypeType(i)
    }
  }
}

impl From<&i32> for TIETypeType {
  fn from(i: &i32) -> Self {
    TIETypeType::from(*i)
  }
}

impl From<TIETypeType> for i32 {
  fn from(e: TIETypeType) -> i32 {
    e.0
  }
}

impl From<&TIETypeType> for i32 {
  fn from(e: &TIETypeType) -> i32 {
    e.0
  }
}

/// RIFT route types.
/// @note: The only purpose of those values is to introduce an
///        ordering whereas an implementation can choose internally
///        any other values as long the ordering is preserved
#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct RouteType(pub i32);

impl RouteType {
  pub const ILLEGAL: RouteType = RouteType(0);
  pub const ROUTE_TYPE_MIN_VALUE: RouteType = RouteType(1);
  /// Discard routes are most preferred
  pub const DISCARD: RouteType = RouteType(2);
  /// Local prefixes are directly attached prefixes on the
  /// system such as e.g. interface routes.
  pub const LOCAL_PREFIX: RouteType = RouteType(3);
  /// Advertised in S-TIEs
  pub const SOUTH_P_G_P_PREFIX: RouteType = RouteType(4);
  /// Advertised in N-TIEs
  pub const NORTH_P_G_P_PREFIX: RouteType = RouteType(5);
  /// Advertised in N-TIEs
  pub const NORTH_PREFIX: RouteType = RouteType(6);
  /// Externally imported north
  pub const NORTH_EXTERNAL_PREFIX: RouteType = RouteType(7);
  /// Advertised in S-TIEs, either normal prefix or positive
  /// disaggregation
  pub const SOUTH_PREFIX: RouteType = RouteType(8);
  /// Externally imported south
  pub const SOUTH_EXTERNAL_PREFIX: RouteType = RouteType(9);
  /// Negative, transitive prefixes are least preferred
  pub const NEGATIVE_SOUTH_PREFIX: RouteType = RouteType(10);
  pub const ROUTE_TYPE_MAX_VALUE: RouteType = RouteType(11);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::ILLEGAL,
    Self::ROUTE_TYPE_MIN_VALUE,
    Self::DISCARD,
    Self::LOCAL_PREFIX,
    Self::SOUTH_P_G_P_PREFIX,
    Self::NORTH_P_G_P_PREFIX,
    Self::NORTH_PREFIX,
    Self::NORTH_EXTERNAL_PREFIX,
    Self::SOUTH_PREFIX,
    Self::SOUTH_EXTERNAL_PREFIX,
    Self::NEGATIVE_SOUTH_PREFIX,
    Self::ROUTE_TYPE_MAX_VALUE,
  ];
}

impl TSerializable for RouteType {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<RouteType> {
    let enum_value = i_prot.read_i32()?;
    Ok(RouteType::from(enum_value))
  }
}

impl From<i32> for RouteType {
  fn from(i: i32) -> Self {
    match i {
      0 => RouteType::ILLEGAL,
      1 => RouteType::ROUTE_TYPE_MIN_VALUE,
      2 => RouteType::DISCARD,
      3 => RouteType::LOCAL_PREFIX,
      4 => RouteType::SOUTH_P_G_P_PREFIX,
      5 => RouteType::NORTH_P_G_P_PREFIX,
      6 => RouteType::NORTH_PREFIX,
      7 => RouteType::NORTH_EXTERNAL_PREFIX,
      8 => RouteType::SOUTH_PREFIX,
      9 => RouteType::SOUTH_EXTERNAL_PREFIX,
      10 => RouteType::NEGATIVE_SOUTH_PREFIX,
      11 => RouteType::ROUTE_TYPE_MAX_VALUE,
      _ => RouteType(i)
    }
  }
}

impl From<&i32> for RouteType {
  fn from(i: &i32) -> Self {
    RouteType::from(*i)
  }
}

impl From<RouteType> for i32 {
  fn from(e: RouteType) -> i32 {
    e.0
  }
}

impl From<&RouteType> for i32 {
  fn from(e: &RouteType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct KVTypes(pub i32);

impl KVTypes {
  pub const OUI: KVTypes = KVTypes(1);
  pub const WELL_KNOWN: KVTypes = KVTypes(2);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::OUI,
    Self::WELL_KNOWN,
  ];
}

impl TSerializable for KVTypes {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<KVTypes> {
    let enum_value = i_prot.read_i32()?;
    Ok(KVTypes::from(enum_value))
  }
}

impl From<i32> for KVTypes {
  fn from(i: i32) -> Self {
    match i {
      1 => KVTypes::OUI,
      2 => KVTypes::WELL_KNOWN,
      _ => KVTypes(i)
    }
  }
}

impl From<&i32> for KVTypes {
  fn from(i: &i32) -> Self {
    KVTypes::from(*i)
  }
}

impl From<KVTypes> for i32 {
  fn from(e: KVTypes) -> i32 {
    e.0
  }
}

impl From<&KVTypes> for i32 {
  fn from(e: &KVTypes) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct AutoEVPNModel(pub i32);

impl AutoEVPNModel {
  pub const ERB_VLAN_BUNDLE: AutoEVPNModel = AutoEVPNModel(0);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::ERB_VLAN_BUNDLE,
  ];
}

impl TSerializable for AutoEVPNModel {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<AutoEVPNModel> {
    let enum_value = i_prot.read_i32()?;
    Ok(AutoEVPNModel::from(enum_value))
  }
}

impl From<i32> for AutoEVPNModel {
  fn from(i: i32) -> Self {
    match i {
      0 => AutoEVPNModel::ERB_VLAN_BUNDLE,
      _ => AutoEVPNModel(i)
    }
  }
}

impl From<&i32> for AutoEVPNModel {
  fn from(i: &i32) -> Self {
    AutoEVPNModel::from(*i)
  }
}

impl From<AutoEVPNModel> for i32 {
  fn from(e: AutoEVPNModel) -> i32 {
    e.0
  }
}

impl From<&AutoEVPNModel> for i32 {
  fn from(e: &AutoEVPNModel) -> i32 {
    e.0
  }
}

/// <auto-flood-reflection>
#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct AutoFRModel(pub i32);

impl AutoFRModel {
  /// Full Mesh of L1 tunnel shortcuts, only model supported currently with auto FR
  pub const TUNNEL_MODE: AutoFRModel = AutoFRModel(0);
  pub const NO_TUNNEL_MODE: AutoFRModel = AutoFRModel(1);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::TUNNEL_MODE,
    Self::NO_TUNNEL_MODE,
  ];
}

impl TSerializable for AutoFRModel {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<AutoFRModel> {
    let enum_value = i_prot.read_i32()?;
    Ok(AutoFRModel::from(enum_value))
  }
}

impl From<i32> for AutoFRModel {
  fn from(i: i32) -> Self {
    match i {
      0 => AutoFRModel::TUNNEL_MODE,
      1 => AutoFRModel::NO_TUNNEL_MODE,
      _ => AutoFRModel(i)
    }
  }
}

impl From<&i32> for AutoFRModel {
  fn from(i: &i32) -> Self {
    AutoFRModel::from(*i)
  }
}

impl From<AutoFRModel> for i32 {
  fn from(e: AutoFRModel) -> i32 {
    e.0
  }
}

impl From<&AutoFRModel> for i32 {
  fn from(e: &AutoFRModel) -> i32 {
    e.0
  }
}

pub type SystemIDType = i64;

pub type IPv4Address = i32;

pub type MTUSizeType = i32;

pub type SeqNrType = i64;

pub type LifeTimeInSecType = i32;

pub type LevelType = i8;

pub type PacketNumberType = i16;

pub type PodType = i32;

pub type IPv6Address = Vec<u8>;

pub type UDPPortType = i16;

pub type TIENrType = i32;

pub type VersionType = i8;

pub type MinorVersionType = i16;

pub type MetricType = i32;

pub type RouteTagType = i64;

pub type LabelType = i32;

pub type BandwithInMegaBitsType = i32;

pub type KeyIDType = i32;

pub type LinkIDType = i32;

pub type PrefixLenType = i8;

pub type TimestampInSecsType = i64;

pub type NonceType = i16;

pub type TimeIntervalInSecType = i16;

pub type PrefixTransactionIDType = i8;

pub type CounterType = i64;

pub type PlatformInterfaceIndex = i32;

pub type OuterSecurityKeyID = i8;

pub type TIESecurityKeyID = i32;

pub type FabricIDType = i16;

pub type FloodReflectionClusterIDType = i32;

pub type FloodReflectionPreferenceType = i32;

//
// IEEE8021ASTimeStampType
//

/// Timestamp per IEEE 802.1AS, all values MUST be interpreted in
/// implementation as unsigned.
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct IEEE8021ASTimeStampType {
  pub a_s_sec: i64,
  pub a_s_nsec: Option<i32>,
}

impl IEEE8021ASTimeStampType {
  pub fn new<F2>(a_s_sec: i64, a_s_nsec: F2) -> IEEE8021ASTimeStampType where F2: Into<Option<i32>> {
    IEEE8021ASTimeStampType {
      a_s_sec,
      a_s_nsec: a_s_nsec.into(),
    }
  }
}

impl TSerializable for IEEE8021ASTimeStampType {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IEEE8021ASTimeStampType> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IEEE8021ASTimeStampType.a_s_sec", &f_1)?;
    let ret = IEEE8021ASTimeStampType {
      a_s_sec: f_1.expect("auto-generated code should have checked for presence of required fields"),
      a_s_nsec: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IEEE802_1ASTimeStampType");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("AS_sec", TType::I64, 1))?;
    o_prot.write_i64(self.a_s_sec)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.a_s_nsec {
      o_prot.write_field_begin(&TFieldIdentifier::new("AS_nsec", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IPv4PrefixType
//

/// IPv4 prefix type.
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct IPv4PrefixType {
  pub address: IPv4Address,
  pub prefixlen: PrefixLenType,
}

impl IPv4PrefixType {
  pub fn new(address: IPv4Address, prefixlen: PrefixLenType) -> IPv4PrefixType {
    IPv4PrefixType {
      address,
      prefixlen,
    }
  }
}

impl TSerializable for IPv4PrefixType {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IPv4PrefixType> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<IPv4Address> = None;
    let mut f_2: Option<PrefixLenType> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i8()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IPv4PrefixType.address", &f_1)?;
    verify_required_field_exists("IPv4PrefixType.prefixlen", &f_2)?;
    let ret = IPv4PrefixType {
      address: f_1.expect("auto-generated code should have checked for presence of required fields"),
      prefixlen: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IPv4PrefixType");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("address", TType::I32, 1))?;
    o_prot.write_i32(self.address)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("prefixlen", TType::I08, 2))?;
    o_prot.write_i8(self.prefixlen)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IPv6PrefixType
//

/// IPv6 prefix type.
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct IPv6PrefixType {
  pub address: IPv6Address,
  pub prefixlen: PrefixLenType,
}

impl IPv6PrefixType {
  pub fn new(address: IPv6Address, prefixlen: PrefixLenType) -> IPv6PrefixType {
    IPv6PrefixType {
      address,
      prefixlen,
    }
  }
}

impl TSerializable for IPv6PrefixType {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IPv6PrefixType> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<IPv6Address> = None;
    let mut f_2: Option<PrefixLenType> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bytes()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i8()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IPv6PrefixType.address", &f_1)?;
    verify_required_field_exists("IPv6PrefixType.prefixlen", &f_2)?;
    let ret = IPv6PrefixType {
      address: f_1.expect("auto-generated code should have checked for presence of required fields"),
      prefixlen: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IPv6PrefixType");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("address", TType::String, 1))?;
    o_prot.write_bytes(&self.address)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("prefixlen", TType::I08, 2))?;
    o_prot.write_i8(self.prefixlen)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IPAddressType
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum IPAddressType {
  Ipv4address(IPv4Address),
  Ipv6address(IPv6Address),
}

impl TSerializable for IPAddressType {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IPAddressType> {
    let mut ret: Option<IPAddressType> = None;
    let mut received_field_count = 0;
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          if ret.is_none() {
            ret = Some(IPAddressType::Ipv4address(val));
          }
          received_field_count += 1;
        },
        2 => {
          let val = i_prot.read_bytes()?;
          if ret.is_none() {
            ret = Some(IPAddressType::Ipv6address(val));
          }
          received_field_count += 1;
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
          received_field_count += 1;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    if received_field_count == 0 {
      Err(
        thrift::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorKind::InvalidData,
            "received empty union from remote IPAddressType"
          )
        )
      )
    } else if received_field_count > 1 {
      Err(
        thrift::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorKind::InvalidData,
            "received multiple fields for union from remote IPAddressType"
          )
        )
      )
    } else {
      Ok(ret.expect("return value should have been constructed"))
    }
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IPAddressType");
    o_prot.write_struct_begin(&struct_ident)?;
    match *self {
      IPAddressType::Ipv4address(f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("ipv4address", TType::I32, 1))?;
        o_prot.write_i32(f)?;
        o_prot.write_field_end()?;
      },
      IPAddressType::Ipv6address(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("ipv6address", TType::String, 2))?;
        o_prot.write_bytes(f)?;
        o_prot.write_field_end()?;
      },
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IPPrefixType
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum IPPrefixType {
  Ipv4prefix(IPv4PrefixType),
  Ipv6prefix(IPv6PrefixType),
}

impl TSerializable for IPPrefixType {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IPPrefixType> {
    let mut ret: Option<IPPrefixType> = None;
    let mut received_field_count = 0;
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = IPv4PrefixType::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(IPPrefixType::Ipv4prefix(val));
          }
          received_field_count += 1;
        },
        2 => {
          let val = IPv6PrefixType::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(IPPrefixType::Ipv6prefix(val));
          }
          received_field_count += 1;
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
          received_field_count += 1;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    if received_field_count == 0 {
      Err(
        thrift::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorKind::InvalidData,
            "received empty union from remote IPPrefixType"
          )
        )
      )
    } else if received_field_count > 1 {
      Err(
        thrift::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorKind::InvalidData,
            "received multiple fields for union from remote IPPrefixType"
          )
        )
      )
    } else {
      Ok(ret.expect("return value should have been constructed"))
    }
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IPPrefixType");
    o_prot.write_struct_begin(&struct_ident)?;
    match *self {
      IPPrefixType::Ipv4prefix(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("ipv4prefix", TType::Struct, 1))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      IPPrefixType::Ipv6prefix(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("ipv6prefix", TType::Struct, 2))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// PrefixSequenceType
//

/// Sequence of a prefix in case of move.
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct PrefixSequenceType {
  pub timestamp: IEEE8021ASTimeStampType,
  /// Transaction ID set by client in e.g. in 6LoWPAN.
  pub transactionid: Option<PrefixTransactionIDType>,
}

impl PrefixSequenceType {
  pub fn new<F2>(timestamp: IEEE8021ASTimeStampType, transactionid: F2) -> PrefixSequenceType where F2: Into<Option<PrefixTransactionIDType>> {
    PrefixSequenceType {
      timestamp,
      transactionid: transactionid.into(),
    }
  }
}

impl TSerializable for PrefixSequenceType {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<PrefixSequenceType> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<IEEE8021ASTimeStampType> = None;
    let mut f_2: Option<PrefixTransactionIDType> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = IEEE8021ASTimeStampType::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i8()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("PrefixSequenceType.timestamp", &f_1)?;
    let ret = PrefixSequenceType {
      timestamp: f_1.expect("auto-generated code should have checked for presence of required fields"),
      transactionid: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PrefixSequenceType");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("timestamp", TType::Struct, 1))?;
    self.timestamp.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.transactionid {
      o_prot.write_field_begin(&TFieldIdentifier::new("transactionid", TType::I08, 2))?;
      o_prot.write_i8(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

pub const UNDEFINED_PACKET_NUMBER: PacketNumberType = 0;

pub const TOP_OF_FABRIC_LEVEL: LevelType = 24;

pub const DEFAULT_BANDWIDTH: BandwithInMegaBitsType = 100;

pub const LEAF_LEVEL: LevelType = 0;

pub const DEFAULT_LEVEL: LevelType = 0;

pub const DEFAULT_POD: PodType = 0;

pub const UNDEFINED_LINKID: LinkIDType = 0;

pub const INVALID_KEY_VALUE_KEY: KeyIDType = 0;

pub const DEFAULT_DISTANCE: MetricType = 1;

pub const INFINITE_DISTANCE: MetricType = 2147483647;

pub const INVALID_DISTANCE: MetricType = 0;

pub const OVERLOAD_DEFAULT: bool = false;

pub const FLOOD_REDUCTION_DEFAULT: bool = true;

pub const DEFAULT_LIE_TX_INTERVAL: TimeIntervalInSecType = 1;

pub const DEFAULT_LIE_HOLDTIME: TimeIntervalInSecType = 3;

pub const MULTIPLE_NEIGHBORS_LIE_HOLDTIME_MULTIPLER: i8 = 4;

pub const DEFAULT_ZTP_HOLDTIME: TimeIntervalInSecType = 1;

pub const DEFAULT_NOT_A_ZTP_OFFER: bool = false;

pub const DEFAULT_YOU_ARE_FLOOD_REPEATER: bool = true;

pub const ILLEGAL_SYSTEM_I_D: SystemIDType = 0;

pub struct ConstEmptySetOfNodeids;
impl ConstEmptySetOfNodeids {
  pub fn const_value() -> BTreeSet<SystemIDType> {
    {
      let mut s: BTreeSet<SystemIDType> = BTreeSet::new();
      s
    }
  }
}

pub const DEFAULT_LIFETIME: LifeTimeInSecType = 604800;

pub const PURGE_LIFETIME: LifeTimeInSecType = 300;

pub const ROUNDDOWN_LIFETIME_INTERVAL: LifeTimeInSecType = 60;

pub const LIFETIME_DIFF2IGNORE: LifeTimeInSecType = 400;

pub const DEFAULT_LIE_UDP_PORT: UDPPortType = 914;

pub const DEFAULT_TIE_UDP_FLOOD_PORT: UDPPortType = 915;

pub const DEFAULT_MTU_SIZE: MTUSizeType = 1400;

pub const BFD_DEFAULT: bool = true;

pub const UNDEFINED_NONCE: NonceType = 0;

pub const UNDEFINED_SECURITYKEY_ID: TIESecurityKeyID = 0;

pub const MAXIMUM_VALID_NONCE_DELTA: i16 = 5;

pub const NONCE_REGENERATION_INTERVAL: TimeIntervalInSecType = 300;

pub const UNDEFINED_FABRIC_ID: FabricIDType = 0;

pub const DEFAULT_FABRIC_ID: FabricIDType = 1;

pub const DEFAULT_ACTING_AUTO_EVPN_DCI_WHEN_TOF: bool = false;

pub struct ConstDefaultAutoevpnModel;
impl ConstDefaultAutoevpnModel {
  pub fn const_value() -> AutoEVPNModel {
    {
      AutoEVPNModel::try_from(0).expect("expecting valid const value")
    }
  }
}

pub struct ConstDefaultAutofrModel;
impl ConstDefaultAutofrModel {
  pub fn const_value() -> AutoFRModel {
    {
      AutoFRModel::try_from(0).expect("expecting valid const value")
    }
  }
}

pub const ILLEGAL_CLUSTER_I_D: FloodReflectionClusterIDType = 0;

pub const DEFAULT_CLUSTER_I_D: FloodReflectionClusterIDType = 1;

pub const MIN_FLOOD_REFLECTION_PREFERENCE: FloodReflectionPreferenceType = 0;

